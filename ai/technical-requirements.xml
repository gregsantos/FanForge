<architecture_overview>
FanForge is a Next 14 / React 18 / TypeScript 5 web application deployed on Vercel with static exports for the public portions of the site.
The runtime stack is split into four layers:
	1.	Edge & Routing
	•	Vercel Edge Network serves static assets and SSR pages.
	•	middleware.ts resolves Supabase Auth JWT cookies and injects { userId, role } into request.nextUrl for route guards.
	2.	Frontend App
	•	Next.js App Router pages organised under (auth), (brand), and (creator) segments.
	•	Tailwind 3 with shadcn/ui components and Lucide icons drive UI.
	•	Forms use React Hook Form 7 with Zod 3 resolvers for schema-driven validation.
	3.	API & Services
	•	Next.js Route Handlers in app/api/** act as thin controllers.
	•	Business logic lives in /lib/services/* and uses Drizzle ORM for all data access.
	•	Supabase Storage issues presigned URLs for asset uploads, and Vercel Cron jobs handle email, cleanup, and metrics.
	4.	Data & Auth
	•	Supabase Postgres 15 + Row-Level Security.
	•	Drizzle ORM + drizzle-kit manage schema and type-safe SQL, following official Drizzle-Supabase guides.  ￼
	•	Supabase Auth provides JWT-backed email/password and OAuth login; sessions live in HTTP-only cookies with automatic rotation.

Cross-cutting concerns—logging (Logflare), monitoring (Vercel Analytics), and audit trails—are wired in at the service layer.
</architecture_overview>

<user_types_and_permissions>

Role	Scope	Permissions
Creator	Self	View campaigns; create/edit own submissions; delete draft; view personal analytics
BrandAdmin	Brand	CRUD campaigns & asset kits; invite BrandReviewer; review/approve/reject submissions; view brand analytics
BrandReviewer	Brand	Review/approve/reject submissions only
PlatformAdmin	Global	Full system access; manage users/brands; feature flags

Implementation notes
	•	Roles are data-driven (roles, user_roles join table).
	•	Permission slugs ("campaign:create", "submission:review") allow future roles (e.g., Moderator, CreatorPro) without code changes.
	•	Both the API layer (assertPermission()) and Postgres RLS enforce the same matrix.
</user_types_and_permissions>

<database_design>
Primary datastore: Supabase Postgres with Drizzle schema definitions and SQL migrations.

// db/schema.ts (excerpt)
export const users = pgTable('users', {
  id: uuid('id').primaryKey().defaultRandom(),
  email: text('email').notNull().unique(),
  passwordHash: text('password_hash'),
  displayName: text('display_name'),
  createdAt: timestamp('created_at').defaultNow(),
});

export const roles = pgTable('roles', {
  id: serial('id').primaryKey(),
  name: text('name').unique(),
});

export const userRoles = pgTable('user_roles', {
  userId: uuid('user_id').references(() => users.id),
  roleId: integer('role_id').references(() => roles.id),
  brandId: uuid('brand_id').references(() => brands.id).nullable(),
});

Other core tables (brands, campaigns, asset_kits, submissions, audit_logs) follow the schema outlined earlier; large binaries live in Supabase Storage.
drizzle-kit generate produces SQL migration files committed under drizzle/migrations/ and applied by CI with supabase db push.
Stable indexes on (campaign_id, status) and TSVector columns back search and discovery.
</database_design>

<technology_stack>
Runtime & Frameworks

Layer	Package	Version
React	react, react-dom	18.2.0
Next.js	next	14.0.0
TypeScript	typescript	5.0.0 (5.2.0 rec.)
Node.js	—	≥ 18.17.0 (20.9.0 rec.)
Styling	tailwindcss 3.3 + tailwindcss-animate	—
UI Kit	shadcn/ui	latest
Icons	lucide-react	0.294.0
Forms	react-hook-form 7.47.0 + @hookform/resolvers	—
Validation	zod 3.22.0	—
ORM	drizzle-orm 0.44.2 + drizzle-kit 0.31.1	—
DB Driver	postgres 3.4.7	—
Supabase SSR	@supabase/ssr 0.6.1	—

Tooling & Quality

ESLint 8.52, Prettier 3, Husky 8, Jest 29, TypeScript-ESLint 6 guarantee code quality and pre-commit safety.

Scripts

"dev": "next dev",
"build": "next build",
"export": "next export",
"type-check": "tsc --noEmit",
"lint": "next lint",
"test": "jest"

</technology_stack>

<development_workflow>
	1.	Bootstrap

npx create-next-app fanforge --ts
cd fanforge && npm install


	2.	Configure Supabase & Drizzle
	•	Add DATABASE_URL, SUPABASE_URL, SUPABASE_ANON_KEY to .env.local.
	•	Create drizzle.config.ts, run npx drizzle-kit introspect to pull schema.
	•	Push migrations: supabase db push.
	3.	Daily work
	•	npm run dev for local server with HMR.
	•	Pre-commit hooks (husky) run lint and type-check.
	•	PRs must pass Jest tests and Drizzle migration diff in CI.
	4.	Deploy
	•	Vercel Git integration; next build && next export produce static assets plus serverless functions for API routes.
	•	Environment variables are injected via Vercel UI Secrets.
	5.	Version targets – see table in Technology Stack. Use nvm to pin Node versions in CI.
</development_workflow>

<technical_constraints>
	•	Performance Budgets: FCP <1.5 s, LCP <2.5 s, CLS <0.1, FID <100 ms.
	•	Browser Support: Chrome 90+, Firefox 88+, Safari 14+, Edge 90+.
	•	Responsive Breakpoints: 320-767 px (mobile), 768-1023 px (tablet), ≥1024 px (desktop).
	•	Accessibility: WCAG 2.1 AA; all interactive elements keyboard-navigable; ARIA roles & labels mandatory.
</technical_constraints>

<file_structure>

.
├── app
│   ├── (auth)/login/page.tsx
│   ├── (auth)/register/page.tsx
│   ├── (brand)/campaigns/[id]/{campaign-detail-client.tsx,page.tsx}
│   ├── (brand)/dashboard/page.tsx
│   ├── (brand)/submissions/page.tsx
│   ├── (creator)/create/page.tsx
│   ├── (creator)/discover/[id]/{campaign-discover-client.tsx,page.tsx}
│   ├── (creator)/portfolio/page.tsx
│   ├── api/{auth,campaigns,submissions}/…
│   ├── globals.css
│   └── layout.tsx
├── components/{canvas,shared,ui}/…
├── db/{schema.ts,index.ts}
├── drizzle.config.ts
├── lib/{mock-data.ts,utils.ts,validations.ts}
├── utils/supabase/{client.ts,middleware.ts,server.ts}
└── …

This structure enforces separation of concerns: UI pages, API routes, domain libraries, and infrastructure helpers all live in predictable locations.
</file_structure>

<environment_configuration>

NEXT_PUBLIC_APP_URL=http://localhost:3000
NEXT_PUBLIC_API_URL=http://localhost:3000/api
NEXT_PUBLIC_SUPABASE_URL=<project>.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=<anon-key>
DATABASE_URL=postgres://...
NODE_ENV=development

// next.config.js
const nextConfig = {
  output: 'export',
  trailingSlash: true,
  images: { unoptimized: true },
};
module.exports = nextConfig;

</environment_configuration>

<security_and_performance_optimization>
Authentication & RBAC
	•	Supabase Auth issues JWTs; cookies set Secure, HttpOnly, SameSite=Lax.
	•	RLS policies replicate API-level checks to guarantee least privilege.

Validation & Sanitisation
	•	All payloads validated with Zod before hitting the DB.
	•	File uploads checked for MIME type, size ≤ 25 MB, and scanned for malware.

Content Security
	•	Global CSP headers via @supabase/ssr middleware: script-src 'self' supabase.com vercel.app; object-src 'none'.
	•	CSRF tokens added to all mutating forms.

Performance
	•	Route-based code splitting (App Router) + dynamic imports for Canvas editor.
	•	Next.js Image component handles responsive images; Tailwind purges unused CSS in production.
	•	Cache-Control: s-maxage=0, stale-while-revalidate=60 on API responses for quick repeat views.

Monitoring
	•	Vercel Web Vitals, Supabase Logflare, and audit trail (audit_logs table) support incident response and compliance.
</security_and_performance_optimization>

<key_decisions_and_rationale>
Drizzle + Supabase gives us type-safe SQL without losing native Postgres power, aligns with official Supabase guidance, and avoids heavy runtimes.  ￼ ￼
Next 14 App Router simplifies segmented routing and automatic code splitting.
Full static export keeps hosting costs predictable while serverless API routes cover authenticated operations.
Data-driven RBAC plus Postgres RLS ensures security at every layer, with audit logs for legal traceability.
Strict tooling (ESLint, Prettier, Husky, Jest) enforces code quality and prevents bad migrations from reaching production.
Combined, these choices deliver a secure, performant, and maintainable platform that meets FanForge’s functional, legal, and performance goals while leaving ample headroom for future features (tokenised licensing, payments, AI tooling) without architectural rework.
</key_decisions_and_rationale>